Kubernetes operators: the next level of application management
Let the machines do the work!
13 Apr 2019
Tags: containers,kubernetes,operator,management,golang

Francesco Romani
Senior Software Engineer, Red Hat
fromani {gmail,redhat}
http://github.com/{mojaves,fromanirh}

* whoami
- sweng @ Red Hat (but opinions and mistakes are my own!)
- works daily(-ish): libvirt, kvm, python, golang, kubernetes
- interested in: more golang, containers, kubernetes; lisp
- happy linux user (red hat linux, debian, ubuntu, fedora)

* Talk outline

1. life in a cluster
2. operations and operators
3. build your own operator

* Life in a cluster

.image images/Container_crane_and_MSC_Sola.jpg 420 _
.caption "Containers are being loaded on the container ship MSC Sola at the container terminal of Bremerhaven in Germany" by Tvabutzku1234, public domain, from Wikimedia Commons

* Expectations

How's managing applications in a kubernetes cluster?

.image images/640px-B747-cockpit.jpg _ 520
.caption "Cockpit of a 747-230 seen at the Technik Museum Speyer (Germany)" by Snowdog, public domain, from Wikimedia commons

* Common management tasks

Let's focus on the stuff everyone takes for granted
1. provision/configuration
2. upgrade
3. uninstall

* Simple provision is simple (1/2)

  apiVersion: extensions/v1beta1
  kind: Deployment
  metadata:
    name: testapp-deployment
  spec:
    replicas: 1
    template:
      metadata:
        labels:
          app: testapp
      spec:
        containers:
        - name: testapp
          image: quay.io/user/testapp
          ports:
          - containerPort: 3000

* Simple provision is simple (2/2)

  kind: Service
  apiVersion: v1
  metadata:
    name: testapp-service
  spec:
    selector:
      app: testapp
    ports:
      - protocol: TCP
        port: 3000
        targetPort: 3000

* A messier provisioning case

Let's try something a bit more advanced.
I want to integrate with the simplest possible external component: Kubernetes itself.

I want to validate the definitions of some kubernetes object my app works with.

Turns out, I want to write and distribute a
.link https://kubernetes.io/docs/reference/access-authn-authz/extensible-admission-controllers/ validating admission control

* A messier provisioning case, continued

EXAMPLE

* A messier provisioning case, continued

EXAMPLE

* A messier provisioning case, continued

EXAMPLE

* A messier provisioning case, continued

EXAMPLE

* Takeaway

.image images/640px-Entropy.jpg _ 500
.caption "Spontaneous increase in disorder of a carefully arranged system. An irreversible process, except with the input of energy" by Alex Dinovitser, Creative Commons Attribution-Share Alike 3.0 Unported, from Wikimedia Commons

Apparently simple tasks may take a sudden turn into a messy state. It's a call for new solutions

* Upgrading

Just pull a new image?
What if
1. we need to undo some changes to the cluster (e.g. config. format changed)
2. we need to uninstall some components (uninistall in disguise!)
3. we need some new artifact
4. ...

You know where this is heading, don't you? :)

* uninstall is simple!

deceptively simple?

  kubectl delete -f manifests.yaml

* Is uninstall always simple?

EXAMPLE

* Distribution

How much stuff do I need to ship?
Just a manifest and an image?
*Many* manifests and an image?
*Many* manifests and *many* images?
Do I need to do extra steps in the middle?

* Solutions?

Automation to the rescue!
I can write a script/helper/ansible role/whatever!

Indeed automating is the whole point!
You need to version it btw
Still needs to connect to the cluster _from_ _outside_ (CLI tool? daemon?)

Wouldn't be better if the automation was _inside_ the cluster?

* Operations and operators

.image images/640px-An_emergency_dispatch_center_in_Finland.jpg
.caption "Emergency dispatch center (emergency response center) in Kerava, Finland" by Pollo, GNU FDL 2.1+, from Wikimedia Commons

* Which problems do we want to solve?

1. Manage a kubernetes application like humans would do, but automatically
2. Embed the domain-specific knowledge in a software unit
3. Make the solution easy to deploy and the consume
4. Focus on the high level items
5. Use kubernetes tools to solve a kubernetes issue :)

* #define operator

.link https://developers.redhat.com/blog/2018/12/18/kubernetes-operators-in-depth?intcmp=701f2000000tjyaAAA From "Kubernetes Operators in Depth":

   An operator is a way of building an application and driving an application on top of Kubernetes,
   behind Kubernetes APIs. The idea is that when you have an application, [...] any complex
   application needs a lot of domain-specific knowledge [...]
   Humans should not be involved in this kind of operation because it kind of breaks the promise that
   containers gave us. Containers’ promise was ‘Hey, you package it once, it runs everywhere.

* Kubernetes applications?

Wait, what's a "kubernetes application"?

  A Kubernetes application is an application that is both deployed on Kubernetes
  and managed using the Kubernetes APIs and kubectl tooling.

.link https://developers.redhat.com/blog/2018/12/18/kubernetes-operators-in-depth/?intcmp=701f2000000tjyaAAA source (among many others)

* Operator definition revised

.link https://operatorhub.io/what-is-an-operator "What is an Operator?"

  The goal of an Operator is to put operational knowledge into software.
  Previously this knowledge only resided in the minds of administrators,
  various combinations of shell scripts or automation software like Ansible.
  It was outside of your Kubernetes cluster and hard to integrate.

* Operator definition, final

TL;DR: consolidate domain knowledge in software running _inside_ a Kubernetes cluster.

.image images/Inception-wordmark.svg.png _ 800
.caption "The wordmark on the cover of the movie Inception" by Know-World, public domain, from Wikimedia Commons

* Building blocks of an Operator

.image images/19th_century_knowledge_mechanisms_homemade_concrete_block_mold_parts.jpg
.caption "19th century knowledge mechanisms homemade concrete block mold parts" by Henry Colin Campbell, Public Domain, from Wikimedia Commons

Let's review what we will use to build our Operator(s)

* Building blocks: CRDs (Custom Resource Definition)

.link https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Definition:

  A resource is an endpoint in the Kubernetes API that stores a collection of API objects
  of a certain kind.
  For example, the built-in pods resource contains a collection of Pod objects.

  A custom resource is an extension of the Kubernetes API that is not necessarily available
  in a default Kubernetes installation.
  It represents a customization of a particular Kubernetes installation.
  However, many core Kubernetes functions are now built using custom resources, making
  Kubernetes more modular.

* CRD Demiystified

CRD : Kubernetes = Class : Object Oriented Programming Language

Use CRDs to add user-defined objects, using the familiar YAML syntax,
that fit and feel native in the Kubernetes infra

You can thus reuse *all* the Kubernetes tooling to manage your resource

This includes 3rd party tools - a CRD behaves like a native resource

* Building blocks: controllers

.link https://kubernetes.io/docs/reference/command-line-tools-reference/kube-controller-manager/ Definition:

  In Kubernetes, a controller is a control loop that watches the shared state of the cluster
  through the apiserver and makes changes attempting to move the current state towards the
  desired state.
  Examples of controllers that ship with Kubernetes today are the replication controller,
  endpoints controller, namespace controller, and serviceaccounts controller.

TL;DR: a control loop

* Building blocks: a control loop?

  for {
    desired := getDesiredState()
    current := getCurrentState()
    makeChanges(desired, current)
  }

* Control loop and Controllers

EXPLAIN

* Operator VS controller

Every operator is-a controller
But not all controllers are operator

Operator = CRD(s) + Controller + focus

.link https://github.com/kubeflow/tf-operator/issues/300 Github discussion with lot of good insights

* Operator = CRD(s) + Controller + focus

.image images/479px-Columbus_Breaking_the_Egg_MET_DP825004.jpg _ 500
.caption Columbus Breaking the Egg, CC0, From Wikimedia Commons

* Typical operator deployment flow (1/3)

First: deploy CRDs

  kubectl create -f my_crd.yaml

Yep, that's it. From now on the user can reason in term of the high level objects.

Is that simple because the *scope* is well defined.

* Typical operator deployment flow (2/3)

Next: deploy the operator

Is a regular yaml manifest.
Is *ONE* regular yaml manifest
Again, the *scope* is well defined - no complexity explosion!

The simplest entry point possible, regardless the complexity of the app we want to manage
All the complexity is now *inside* the operator

Abstraction FTW!

* Typical operator deployment flow (3/3)

Deploy CRs as needed

.link https://github.com/coreos/prometheus-operator Let's pick Prometheus monitoring as example
We just worry about what we want to monitor

  ---
  apiVersion: monitoring.coreos.com/v1
  kind: ServiceMonitor
  metadata:
    name: my-monitor
  spec:
    selector:
      matchLabels:
        my-monitor: "my-app"
    endpoints:
    - port: metrics
      scheme: http

* Prometheus configuration

TODO

* Advantages

But: you just want to monitor your app, don't you?
1. with operator CR, you just focus on what you care about
2. if you use bare prometheus, you need to *learn* prometheus configuration file syntax
2. if you use bare prometheus, you need to *debug*/*troubleshoot* prometheus configuration file syntax
3. if you ure bare prometheus, you need to *maintain* the prometheus configuration file

Actually, even prometheus docs suggest the operator :)
.link https://prometheus.io/docs/prometheus/latest/configuration/configuration/#kubernetes_sd_config "You may wish to check out the 3rd party Prometheus Operator, which automates the Prometheus setup on top of Kubernetes"

* Finding/Publishing operators

.link https://operatorhub.io/ OperatorHUB.io

  OperatorHub.io is a new home for the Kubernetes community to share Operators

.link https://github.com/operator-framework/awesome-operators Curated list of operators

* Build your own

.link https://github.com/operator-framework/operator-sdk There is a handy SDK

Benefits of the SDK:

1. High level APIs and abstractions to write the operational logic more intuitively
2. Tools for scaffolding and code generation to bootstrap a new project fast
3. Extensions to cover common operator use cases

* kinds of operators

Options, sorted by decreasing possible integration

1. *GO* native operator - deepest possible integration
2. *Ansible* operator - reuse roles, cover basic needs
3. *Helm* operator - reuse helm charts, cover basic needs

* Example: ansible operator (1/4)

Scaffolding handled by the `operator-sdk` tool

.link https://github.com/operator-framework/operator-sdk#quick-start Quickstart

base image: `quay.io/water-hole/ansible-operator`

* Example: ansible operator (2/4)

Define the CRDs you want to manage

`operator-sdk` helps defining the resources

* Example: ansible operator (3/4)

Add the role(s) and the playbook(s)

* Example: ansible operator (4/4)

use `watch.yaml` to wire the resource(s) to monitor and the playbook(s) to run

  - version: v1
    group: myapp.io
    kind: MyResource
    playbook: /opt/ansible/my_paybook.yaml

*Done!*

* PENDING

PENDING

* Talk wrap up (1/4)

what we seen?

1. life in a cluster
2. operations and operators
3. build your own operator

* Talk wrap up (2/4)

Life in a cluster:

Managing *complex* (multi-component, integrated in the platform) requires *complex* procedures

Automation already exists (ansible, scripts...)

Automation runs outside the cluster

* Talk wrap up (3/4)

Operator pattern to the rescue!

* Talk wrap up (4/4)

How to build your own operator

* Q? A!

Questions?

Slides & more @ https://github.com/mojaves/
